name: Trigger Cosmos Sync All Places

on:
  workflow_call:
    inputs:
      limit:
        description: 'Maximum number of places to sync (optional, leave empty for all)'
        required: false
        default: ''
        type: string
      batch_size:
        description: 'Degree of parallelism for processing places (default: 1 = sequential). Keep low (1-10) to avoid Cosmos DB 429 errors.'
        required: false
        default: '1'
        type: string
      force:
        description: 'Force sync all places regardless of changes (true/false). Default is false (incremental sync - only sync places modified since last sync).'
        required: false
        default: 'false'
        type: string
  workflow_dispatch:
    inputs:
      limit:
        description: 'Maximum number of places to sync (optional, leave empty for all)'
        required: false
        default: ''
        type: string
      batch_size:
        description: 'Degree of parallelism for processing places (default: 1 = sequential). Keep low (1-10) to avoid Cosmos DB 429 errors.'
        required: false
        default: '1'
        type: string
      force:
        description: 'Force sync all places regardless of changes (true/false). Default is false (incremental sync - only sync places modified since last sync).'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

concurrency: 
  group: cosmos-sync-places
  cancel-in-progress: true

jobs:
  trigger-cosmos-sync-places:
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Invoke PowerShell Script
        id: invoke_script
        shell: pwsh
        working-directory: ./scripts
        env:
          AZURE_FUNCTION_KEY: ${{ secrets.AZURE_FUNCTION_KEY }}
        run: |
          $limit = "${{ inputs.limit }}"
          $batchSize = "${{ inputs.batch_size }}"
          $force = "${{ inputs.force }}"
          
          $FunctionUrl = "https://third-places-data.azurewebsites.net/api/cosmos/sync-places"
          $queryParams = @()
          
          if ($limit -ne '') {
            $queryParams += "limit=$limit"
          }
          
          if ($batchSize -ne '') {
            $queryParams += "batch_size=$batchSize"
          }
          
          if ($force -ne '' -and $force -ne 'false') {
            $queryParams += "force=$force"
          }
          
          if ($queryParams.Count -gt 0) {
            $FunctionUrl += "?" + ($queryParams -join "&")
          }
          
          Write-Host "Using function URL: $FunctionUrl"
          Write-Host "Force sync: $force"
          
          $FunctionKey = "$Env:AZURE_FUNCTION_KEY"
          
          # Call the durable function script and capture its output
          $scriptOutput = ./Invoke-AzureDurableFunction.ps1 -FunctionUrl $FunctionUrl -FunctionKey $FunctionKey -TimeoutSeconds 18000 | Out-String
          $scriptExitCode = $LASTEXITCODE
          
          # Print the output so it appears in logs
          Write-Host $scriptOutput
          
          # Parse the JSON from the script output (it prints "Final Azure Function Output:" followed by JSON)
          try {
            # Extract the JSON portion after "Final Azure Function Output:"
            if ($scriptOutput -match "Final Azure Function Output:\s*(\{[\s\S]*\})") {
              $jsonString = $Matches[1]
              $status = $jsonString | ConvertFrom-Json
              $output = $status.output
              
              # --- GENERATE GITHUB SUMMARY ---
              echo "## Cosmos DB Sync Report" >> $env:GITHUB_STEP_SUMMARY
              echo "" >> $env:GITHUB_STEP_SUMMARY
              
              if ($status.runtimeStatus -ne "Completed") {
                echo "### ❌ Sync Failed" >> $env:GITHUB_STEP_SUMMARY
                echo "" >> $env:GITHUB_STEP_SUMMARY
                echo "Runtime status: ``$($status.runtimeStatus)``" >> $env:GITHUB_STEP_SUMMARY
              }
              elseif ($null -eq $output -or $output.success -ne $true) {
                echo "### ❌ Sync Completed with Errors" >> $env:GITHUB_STEP_SUMMARY
                echo "" >> $env:GITHUB_STEP_SUMMARY
                if ($output.error) {
                  echo "**Error:** $($output.error)" >> $env:GITHUB_STEP_SUMMARY
                }
                if ($output.failedAt) {
                  echo "**Failed at place:** $($output.failedAt)" >> $env:GITHUB_STEP_SUMMARY
                }
              }
              else {
                # Success - generate full report
                $placesProcessed = $output.placesProcessed
                $placesSkipped = $output.placesSkipped
                $totalChunks = $output.totalChunksProcessed
                $chunksSkipped = $output.totalChunksSkipped
                $totalPlaces = $output.totalPlaces
                $forceSync = $output.force
                
                if ($placesProcessed -eq 0 -and $placesSkipped -gt 0) {
                  echo "### ✅ No Changes Needed" >> $env:GITHUB_STEP_SUMMARY
                  echo "" >> $env:GITHUB_STEP_SUMMARY
                  echo "All **$totalPlaces** places are already in sync. No updates required." >> $env:GITHUB_STEP_SUMMARY
                } else {
                  echo "### ✅ Sync Completed Successfully" >> $env:GITHUB_STEP_SUMMARY
                }
                
                echo "" >> $env:GITHUB_STEP_SUMMARY
                echo "### Summary" >> $env:GITHUB_STEP_SUMMARY
                echo "" >> $env:GITHUB_STEP_SUMMARY
                echo "| Metric | Count |" >> $env:GITHUB_STEP_SUMMARY
                echo "|--------|-------|" >> $env:GITHUB_STEP_SUMMARY
                echo "| **Total Places in Airtable** | $totalPlaces |" >> $env:GITHUB_STEP_SUMMARY
                echo "| **Places Synced** | $placesProcessed |" >> $env:GITHUB_STEP_SUMMARY
                echo "| **Places Skipped** (no changes) | $placesSkipped |" >> $env:GITHUB_STEP_SUMMARY
                echo "| **Review Chunks Processed** | $totalChunks |" >> $env:GITHUB_STEP_SUMMARY
                echo "| **Review Chunks Skipped** (empty text) | $chunksSkipped |" >> $env:GITHUB_STEP_SUMMARY
                echo "| **Force Sync** | $forceSync |" >> $env:GITHUB_STEP_SUMMARY
                
                # List synced places
                if ($placesProcessed -gt 0 -and $output.placeDetails) {
                  echo "" >> $env:GITHUB_STEP_SUMMARY
                  echo "### Synced Places ($placesProcessed)" >> $env:GITHUB_STEP_SUMMARY
                  echo "" >> $env:GITHUB_STEP_SUMMARY
                  echo "| Place Name | Place ID | Chunks |" >> $env:GITHUB_STEP_SUMMARY
                  echo "|------------|----------|--------|" >> $env:GITHUB_STEP_SUMMARY
                  foreach ($place in $output.placeDetails) {
                    # Escape pipe characters in place name to prevent Markdown table breakage
                    $escapedName = $place.placeName -replace '\|', '\|'
                    $id = $place.placeId
                    $chunks = $place.chunksProcessed
                    echo "| $escapedName | ``$id`` | $chunks |" >> $env:GITHUB_STEP_SUMMARY
                  }
                }
                
                # List skipped places (collapsed for brevity if many)
                if ($placesSkipped -gt 0 -and $output.skippedPlaces) {
                  echo "" >> $env:GITHUB_STEP_SUMMARY
                  if ($placesSkipped -gt 20) {
                    echo "<details>" >> $env:GITHUB_STEP_SUMMARY
                    echo "<summary>Skipped Places ($placesSkipped) - click to expand</summary>" >> $env:GITHUB_STEP_SUMMARY
                    echo "" >> $env:GITHUB_STEP_SUMMARY
                  } else {
                    echo "### Skipped Places ($placesSkipped)" >> $env:GITHUB_STEP_SUMMARY
                    echo "" >> $env:GITHUB_STEP_SUMMARY
                    echo "These places had no changes since their last sync:" >> $env:GITHUB_STEP_SUMMARY
                    echo "" >> $env:GITHUB_STEP_SUMMARY
                  }
                  echo "| Place Name | Reason |" >> $env:GITHUB_STEP_SUMMARY
                  echo "|------------|--------|" >> $env:GITHUB_STEP_SUMMARY
                  foreach ($place in $output.skippedPlaces) {
                    # Escape pipe characters in place name to prevent Markdown table breakage
                    $escapedName = $place.placeName -replace '\|', '\|'
                    $reason = $place.reason
                    echo "| $escapedName | $reason |" >> $env:GITHUB_STEP_SUMMARY
                  }
                  if ($placesSkipped -gt 20) {
                    echo "" >> $env:GITHUB_STEP_SUMMARY
                    echo "</details>" >> $env:GITHUB_STEP_SUMMARY
                  }
                }
              }
              
              Write-Host "Summary generated successfully."
            }
            else {
              Write-Warning "Could not find JSON output in script response"
              echo "## Cosmos DB Sync Report" >> $env:GITHUB_STEP_SUMMARY
              echo "" >> $env:GITHUB_STEP_SUMMARY
              echo "Summary generation failed - could not parse script output." >> $env:GITHUB_STEP_SUMMARY
            }
          }
          catch {
            Write-Warning "Failed to generate summary: $_"
            echo "## Cosmos DB Sync Report" >> $env:GITHUB_STEP_SUMMARY
            echo "" >> $env:GITHUB_STEP_SUMMARY
            echo "Summary generation failed. Check the workflow logs for details." >> $env:GITHUB_STEP_SUMMARY
          }
          
          # Exit with the original script's exit code
          if ($scriptExitCode -ne 0) {
            Write-Error "Azure Function call failed."
            exit $scriptExitCode
          } else {
            Write-Output "Azure Function call succeeded."
          }

      - name: Check Script Result
        if: always()
        run: |
          echo "Script execution completed with status: ${{ steps.invoke_script.outcome }}"
          if ("${{ steps.invoke_script.outcome }}" -ne "success") {
            exit 1
          }

      - name: Purge Orchestrations
        if: always()
        shell: pwsh
        working-directory: ./scripts
        env:
          AZURE_FUNCTION_KEY: ${{ secrets.AZURE_FUNCTION_KEY }}
        run: |
          Write-Host "Cleaning up completed orchestrations..."
          $FunctionUrl = "https://third-places-data.azurewebsites.net/api/purge-orchestrations"
          $FunctionKey = "$Env:AZURE_FUNCTION_KEY"
          ./Invoke-AzureFunction.ps1 -FunctionUrl $FunctionUrl -FunctionKey $FunctionKey -TimeoutSeconds 300
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Orchestration purge failed, but this is non-critical."
          } else {
            Write-Host "Orchestration purge completed."
          }
